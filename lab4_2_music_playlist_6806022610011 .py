# -*- coding: utf-8 -*-
"""Lab4-2_Music Playlist_6806022610011.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hGVJmHH07qWWfUf2VrsQGGHPSzWLuNO3

#Lab4-2 ‡∏Å‡∏≤‡∏£‡∏ô‡∏≥ Linked List ‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

### Music Playlist

First, let's define the `Song` class. Each `Song` object will represent a node in our linked list, containing song details and a pointer to the next song.
"""

class Song:
    def __init__(self, title, artist):
        self.title = title
        self.artist = artist
        self.next_song = None

    def __str__(self):
        return f"{self.title} by {self.artist}"

"""Next, we'll define the `MusicPlaylist` class, which will manage the collection of `Song` objects using a linked list. It will have methods to add songs, display the playlist, and optionally play songs (though 'playing' here is just printing the song details)."""

# @title
class MusicPlaylist:
    def __init__(self):
        self.head = None  # ‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏£‡∏Å
        self.current_song = None # ‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà (‡πÄ‡∏û‡∏•‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î)
        self.length = 0  # ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏Å‡∏µ‡πà‡πÄ‡∏û‡∏•‡∏á

    def add_song(self, title, artist): # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á
        new_song = Song(title, artist)
        if self.head is None: # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏£‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á (‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏£‡∏Å)
            self.head = new_song
            self.current_song = new_song # If first song, it's also the current one
        else:
            current = self.head # ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏£‡∏Å
            while current.next_song:
                current = current.next_song
            current.next_song = new_song
        self.length += 1
        print(f"Added: {new_song}")

    def display_playlist(self): # print ‡πÄ‡∏û‡∏•‡∏á‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏î‡∏π
        if self.head is None:
            print("Playlist is empty.")
            return

        current = self.head # ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏•‡∏á
        print("\n--- Your Music Playlist ---")
        count = 1
        while current:
            print(f"{count}. {current}")
            current = current.next_song
            count += 1
        print("---------------------------")

    def play_current_song(self): # ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏≠‡∏∞‡πÑ‡∏£‡∏≠‡∏¢‡∏π‡πà
        if self.current_song:
            print(f"\nNow playing: {self.current_song}")
        else:
            print("Playlist is empty or no song is selected to play.")

    def next_song(self): # ‡πÄ‡∏û‡∏•‡∏á‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
        if self.current_song and self.current_song.next_song:
            self.current_song = self.current_song.next_song
            self.play_current_song()
        elif self.current_song and not self.current_song.next_song:
            print("End of playlist. No next song.")
        else:
            print("Playlist is empty.")

    def prev_song(self): # ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö
        if self.head is None or self.current_song is None:
            print("Playlist is empty or no song is selected.")
            return
        if self.current_song == self.head:
            print("Already at the beginning of the playlist.")
            return

        current = self.head
        while current.next_song != self.current_song:
            current = current.next_song
        self.current_song = current
        self.play_current_song()

    def get_length(self):
        return self.length

    def delete_song(self, title):
        if self.head is None:
            print(f"Cannot delete '{title}'. Playlist is empty.")
            return

        # If the song to be deleted is the head
        if self.head.title == title:
            if self.current_song == self.head:
                self.current_song = self.head.next_song
            self.head = self.head.next_song
            self.length -= 1
            print(f"Deleted: {title}")
            if self.length == 0:
                self.current_song = None
            return

        current = self.head
        prev = None
        while current and current.title != title:
            prev = current
            current = current.next_song

        if current:
            if self.current_song == current:
                # If the deleted song was the current song, try to set the next song as current
                # If no next, then previous. If no previous, then current becomes None.
                if current.next_song:
                    self.current_song = current.next_song
                elif prev:
                    self.current_song = prev
                else:
                    self.current_song = None # Only one song, and it was deleted

            prev.next_song = current.next_song
            self.length -= 1
            print(f"Deleted: {title}")
        else:
            print(f"Song '{title}' not found in the playlist.")

"""Now, let's demonstrate how to use these classes to create and manage a music playlist."""

# Create a new playlist
my_playlist = MusicPlaylist()

# Add some songs
my_playlist.add_song("Bohemian Rhapsody", "Queen")
my_playlist.add_song("Stairway to Heaven", "Led Zeppelin")
my_playlist.add_song("Hotel California", "Eagles")
my_playlist.add_song("Imagine", "John Lennon")

# Display the entire playlist
my_playlist.display_playlist()

# Play the current song (which should be the first one added)
my_playlist.play_current_song()

# Move to the next song and play it
my_playlist.next_song()

# Move to the next song again
my_playlist.next_song()

# Go back to the previous song
my_playlist.prev_song()

# Try to go back again (should indicate already at beginning)
my_playlist.prev_song()

# Move to the end of the playlist
my_playlist.next_song()
my_playlist.next_song()
my_playlist.next_song()

# Try to move next from the end
my_playlist.next_song()

# Check playlist length
print(f"\nPlaylist length: {my_playlist.get_length()} songs")

# Delete a song that exists
my_playlist.delete_song("Stairway to Heaven")
my_playlist.delete_song("Hotel California")
my_playlist.display_playlist()

# Play the current song (which should be the first one added)
my_playlist.play_current_song()

# Try to move next from the end
my_playlist.next_song()

# Check playlist length
print(f"\nPlaylist length: {my_playlist.get_length()} songs")

my_playlist2 = MusicPlaylist()
my_playlist2.add_song("Thunder", "LISA")
my_playlist2.add_song("Rockstar", "LISA")
my_playlist2.play_current_song()
my_playlist2.next_song()
my_playlist2.next_song()

"""#‡∏™‡∏£‡πâ‡∏≤‡∏á Web App

1. installing **streamlit** and **pyngrok** libraries
"""

pip install streamlit pyngrok

"""2. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .py"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# 
# # --- Song Class ---
# class Song:
#     def __init__(self, title, artist):
#         self.title = title
#         self.artist = artist
#         self.next_song = None
# 
#     def __str__(self):
#         return f"{self.title} by {self.artist}"
# 
# # --- MusicPlaylist Class ---
# class MusicPlaylist:
#     def __init__(self):
#         self.head = None
#         self.current_song = None
#         self.length = 0
# 
#     def add_song(self, title, artist):
#         new_song = Song(title, artist)
#         if self.head is None:
#             self.head = new_song
#             self.current_song = new_song
#         else:
#             current = self.head
#             while current.next_song:
#                 current = current.next_song
#             current.next_song = new_song
#         self.length += 1
#         st.success(f"Added: {new_song}")
# 
#     def display_playlist(self):
#         if self.head is None:
#             return []
# 
#         playlist_songs = []
#         current = self.head
#         count = 1
#         while current:
#             playlist_songs.append(f"{count}. {current.title} by {current.artist}")
#             current = current.next_song
#             count += 1
#         return playlist_songs
# 
#     def play_current_song(self):
#         if self.current_song:
#             st.info(f"Now playing: {self.current_song}")
#         else:
#             st.warning("Playlist is empty or no song is selected to play.")
# 
#     def next_song(self):
#         if self.current_song and self.current_song.next_song:
#             self.current_song = self.current_song.next_song
#         elif self.current_song and not self.current_song.next_song:
#             st.warning("End of playlist. No next song.")
#         else:
#             st.warning("Playlist is empty.")
# 
#     def prev_song(self):
#         if self.head is None or self.current_song is None:
#             st.warning("Playlist is empty or no song is selected.")
#             return
#         if self.current_song == self.head:
#             st.warning("Already at the beginning of the playlist.")
#             return
# 
#         current = self.head
#         while current.next_song != self.current_song:
#             current = current.next_song
#         self.current_song = current
# 
#     def get_length(self):
#         return self.length
# 
#     def delete_song(self, title):
#         if self.head is None:
#             st.error(f"Cannot delete '{title}'. Playlist is empty.")
#             return
# 
#         if self.head.title == title:
#             if self.current_song == self.head:
#                 self.current_song = self.head.next_song
#             self.head = self.head.next_song
#             self.length -= 1
#             st.success(f"Deleted: {title}")
#             if self.length == 0:
#                 self.current_song = None
#             return
# 
#         current = self.head
#         prev = None
#         while current and current.title != title:
#             prev = current
#             current = current.next_song
# 
#         if current:
#             if self.current_song == current:
#                 if current.next_song:
#                     self.current_song = current.next_song
#                 elif prev:
#                     self.current_song = prev
#                 else:
#                     self.current_song = None
# 
#             prev.next_song = current.next_song
#             self.length -= 1
#             st.success(f"Deleted: {title}")
#         else:
#             st.error(f"Song '{title}' not found in the playlist.")
# 
# # --- Streamlit App Layout ---
# st.title("üé∂ Music Playlist App")
# 
# # Initialize playlist in session state
# if 'playlist' not in st.session_state:
#     st.session_state.playlist = MusicPlaylist()
# 
# # Sidebar for adding songs
# st.sidebar.header("Add New Song")
# new_title = st.sidebar.text_input("Title")
# new_artist = st.sidebar.text_input("Artist")
# if st.sidebar.button("Add Song to Playlist"):
#     if new_title and new_artist:
#         st.session_state.playlist.add_song(new_title, new_artist)
#     else:
#         st.sidebar.warning("Please enter both title and artist.")
# 
# st.sidebar.markdown("--- üé∂")
# st.sidebar.header("Delete Song")
# delete_title = st.sidebar.text_input("Song Title to Delete")
# if st.sidebar.button("Delete Song"):
#     if delete_title:
#         st.session_state.playlist.delete_song(delete_title)
#     else:
#         st.sidebar.warning("Please enter a song title to delete.")
# 
# # Main content for playlist display and controls
# st.header("Your Current Playlist")
# playlist_content = st.session_state.playlist.display_playlist()
# if playlist_content:
#     for song_str in playlist_content:
#         st.write(song_str)
# else:
#     st.write("Playlist is empty. Add some songs from the sidebar!")
# 
# st.markdown("--- üé∂")
# st.header("Playback Controls")
# col1, col2, col3 = st.columns(3)
# 
# with col1:
#     if st.button("‚è™ Previous"):
#         st.session_state.playlist.prev_song()
#         st.session_state.playlist.play_current_song()
# 
# with col2:
#     if st.button("‚ñ∂Ô∏è Play Current"):
#         st.session_state.playlist.play_current_song()
# 
# with col3:
#     if st.button("‚è© Next"):
#         st.session_state.playlist.next_song()
#         st.session_state.playlist.play_current_song()
# 
# st.markdown("--- üé∂")
# st.write(f"Total songs in playlist: {st.session_state.playlist.get_length()} song(s)")
# 
# st.markdown("--- üéß")
# st.header("Upload Audio File for Current Song")
# 
# uploaded_audio = st.file_uploader(
#     "Upload audio file (mp3 / wav)",
#     type=["mp3", "wav"]
# )
# 
# if uploaded_audio:
#     if st.session_state.playlist.current_song:
#         st.session_state.playlist.current_song.audio = uploaded_audio
#         st.success(
#             f"Audio uploaded for: {st.session_state.playlist.current_song.title}"
#         )
#     else:
#         st.warning("No song selected to attach audio.")
# 
# current = st.session_state.playlist.current_song
# if current and hasattr(current, "audio"):
#     st.markdown("### üîä Now Playing Audio")
#     st.audio(current.audio)

"""3. Login **ngrok** ‡∏ó‡∏µ‡πà https://ngrok.com/ and copy your **authtoken**"""

!ngrok authtoken 36Gu5wZMWoq2VXZjQzgbveDHH6C_6GdnLXtxLRCEQdWpRv8N

from pyngrok import ngrok

ngrok.kill()  # ‡∏õ‡∏¥‡∏î tunnel ‡πÄ‡∏Å‡πà‡∏≤

public_url = ngrok.connect(8501)
print("üåç Open your app here:", public_url)

"""4. **‡∏£‡∏±‡∏ô app Streamlit** ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤
‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏Å‡πÉ‡∏´‡πâ Colab ‡∏£‡∏±‡∏ô‡πÑ‡∏ü‡∏•‡πå calculator.py ‡∏î‡πâ‡∏ß‡∏¢ Streamlit ‡∏ö‡∏ô‡∏û‡∏≠‡∏£‡πå‡∏ï 8501
"""

!streamlit run app.py --server.port 8501 &